## LIBUV & ASYNC IO
- nodeJS is event driven architecture async IO
- JS is synchronous single threaded programming language
- synchronous means it will execute code one after other
- multithreaded it means it take some piece of code and execute in one thread and another piece of code in another thread
- but with single threaded you cannot do a lot of task at once , it executes one after other

### Synchronous 
- let's understand it with an example , let's say we are at a restaurant, and it serves pizza which take 10 min, serves burger which takes 5 mins to prepare and coke which is being served in 0 mins
-  now let's we have 5 customer, 1st customer orders pizza , 2nd order burger, 3rd orders coke, 4th again burger , 5th wants coke
-  now 1st order is of pizza and it takes pizza 10 mins, now next order cannot be served until the first is completed , even if someone wants coke which take 0 mins
-  once 10 mins is passed now pizza can be served , after this 2nd order will be served which takes 5 mins to complete, after 5 mins 3rd order will be take and served in 0 mins
-  so here in synchronous execution even something that take 0 mins had to wait for 15 minutes

### Asynchronous
- in asynchronous, we have same order let's say, 1st order comes and it takes 10 min to prepare so it will put it in queue, then 2nd order comes it will take 5 min so puts it again in queue, 3rd order of coke will be served immediately, 4th order comes for burger, 5th coke will be served immediately, now as 5minutes passes burger will be served to 2nd and 4th order after 10 mins pizza will also be served, so this way asynchronous execution happens faster

### Let's see how synchronous code is executed in js
```js
var a = 123
var b = 234

function multiply(a,b){
  var result = a*b
  return result
}

var c = multiply(a,b)
```
<img width="430" alt="image" src="https://github.com/user-attachments/assets/4aae119d-7436-4608-9650-98474c836d30" />

- first thing that happens when this code is being executed by v8, it creates global execution context inside call stack, when 1st line of code is executed, v8 will assign memory in heap, does the same for next line, again for function declaration it will be stored in memory heap, now when function is inovked , a functional execution context is created and function start running , result variable is created in heap, and a*b value will be stored in result , and returned to c, when function execution is completed functional execution context is also removed, and result variable which was created in memory heap , it was in functional scope , so this will be garbage collected, and c variable in memory will be stored with result of multiply
- 
