### LibUv And EventLoop
- As we saw in the previous notes whenever there is async code nodejs sends these code to libuv and execution thread moves ahead , once the main execution thread is available and the code that were sent to libuv let's setTimeout, if it ready to be executed , then this callback will be sent to call stack for execution
- but the question is how are these callback sent to call stack, there can be many callback coming from setTimout , setInterval, setImmediate, I/O callbacks,
- how are these callbacks being manged , so it is event loop which manages these callback , it manages the order of execution which callback will be executed when and what time
- event loops keeps checking callback queue and call stack , once the call stack or main execution thread is free , and when callback are ready to be executed then it will be sent to call stack by eventloop
<img width=400 height=400 src="https://github.com/user-attachments/assets/5d2f0407-c58e-4c5b-9354-bf0836b96f45">

<img width=400 height=400 src="https://github.com/user-attachments/assets/8e349e63-6b98-412f-8913-d9674eeaaea7">

- above is the image shown how event loops works
- event loop works in phases first it checks for timers callbacks like setTimeout or setInterval then it goes to poll (where it waits when there is no other callbacks) checks if there is any I/O callbacks callbacks from fs, https.get, crypto and such... then it goes on to check for setImmediate, and after that in the end it will check close() if socket needs to be closed
- so above is the execution phase of event loop, but there is one priority queue shown inside in the image process.nextTick and promise which will run before every phase
- for eaxmple when event loop starts, and before running the timers phase it will first check the priority queueand checks if there are any process.nextTick or promise callbacks to be executed and then move to timers phase once timers phase is executed again priority queue will be checked (the inner loop will run ) again goest to poll phase then inner loop then moves to check setImmediate then innerloop then close phase then inner loop then timer phase again , this is how it keeps running

### let's understand it with once code example

```js
const fs = require("fs")
const a = 10

setImmediate(()=>{console.log("setImmediate")})
fs.readFile("./file.txt", "utf8", (err, data)=> {console.log("file rading callback")})
setTimeout(()=> console.log('setTimeout'))
console.log(a)
console.log("end of the line")
```

- now when code start its execution reads line 1 and loads fs and allocate memory for varaible a in memory heap
- the setImmediate nodejs will send it to libuv to handle
- again fs.readFile async code nodejs will send it to libuv to handle
- setTimeout again will be sent to libuv
- now synchronous code will be executed a will be printed and then end of the line will be printed
- now call ctack is empty and main thread is unblocked
- now as we know event loop keeps checking call stack and callback queue once call stack is empty it will start sending callbacks to call  stack for execution
- now setTimeout and setImmediate will be ready immediately , thus setTimout in its first phase will be checked and executed (even before priority queue would have checked since it was empty and will process further) and now again goes to check priority quest aftet this goest to poll phase where no callbacks are there as reading file will take time after this again goes to inner loop i.e., priority queue, then move to setImmediate check there is callback waiting then it will be executed
- and then in the end goest to close phase and then again checks inner loop then timner phase (which is empty thus moves murther) again inner loop then let's file has been read and it is ready to be executed the event loop will send this file callback to call stack to execute it


### another example [code]()
