```ts
import { Schema, model, HydratedDocument, Model } from 'mongoose';

// 1. Define the raw document interface
interface IUser {
  name: string;
  email: string;
}

// 2. Define an interface for the instance methods
interface UserMethods {
  // Define the method signature
  updateEmail(newEmail: string): Promise<this>;
}

// Optional: Define an interface for static methods (if any)
interface UserModelType extends Model<IUser, {}, UserMethods> {
  // Add static methods here if needed
}

// 3. Define the schema with generics
// The 3rd generic param is for instance methods (UserMethods)
const userSchema = new Schema<IUser, UserModelType, UserMethods>({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
}, {
  // 4. Implement the methods using the 'methods' option
  // This is the preferred way for automatic type inference
  methods: {
    async updateEmail(newEmail: string): Promise<this> {
      this.email = newEmail;
      return this.save();
    }
  }
});

// Alternative way to add methods (less type inference, requires manual typing)
// userSchema.methods.updateEmail = async function (newEmail: string): Promise<any> {
//   this.email = newEmail;
//   return this.save();
// };

// 5. Create the model
const UserModel = model<IUser, UserModelType>('User', userSchema);

// Usage
async function runExample() {
  const userDoc = new UserModel({ name: 'Test User', email: 'test@example.com' });
  await userDoc.save();

  // Accessing the method on the document instance
  await userDoc.updateEmail('new.email@example.com'); // This should now work correctly and be type-safe
  console.log(userDoc.email);
}

runExample();
```
