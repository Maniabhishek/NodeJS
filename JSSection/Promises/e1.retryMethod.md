- create a function that resolves after 5th attempt
- and then create a retry method which keeps calling the previous function (which returns the promise) for n number of times 
```js

function getUnReliableTask(){
    let attempt = 1
    return function unreliableTask(){
        return new Promise((res, rej)=> {
            if(attempt < 6) {
                attempt++
                rej("failed")
            }
            else {
                res("success")
            }
        })
    }
}

const unreliableTask = getUnReliableTask()

console.log("start")
unreliableTask().then((d) => {
    console.log("1st call ", d)
}).catch((err)=> {
    console.log("1st call ", err)
})

unreliableTask().then((d) => {
    console.log("2nd call ", d)
}).catch((err)=> {
    console.log("2nd call ", err)
})

unreliableTask().then((d) => {
    console.log("3rd call ", d)
}).catch((err)=> {
    console.log("3rd call ", err)
})

unreliableTask().then((d) => {
    console.log("4th call ", d)
}).catch((err)=> {
    console.log("4th call ", err)
})

unreliableTask().then((d) => {
    console.log("5th call ", d)
}).catch((err)=> {
    console.log("5th call ", err)
})

unreliableTask().then((d) => {
    console.log("6th call ", d)
}).catch((err)=> {
    console.log("6th call ", err)
})
```
- if you see the output of above result you will see success is printed first , its because all the method calls are returning promises hence all of these are sent to priority queue , and hence when returned reolved is being prioritized

[continuation here](https://github.com/Maniabhishek/NodeJS/blob/main/JSSection/Promises/e2.retryMethod.md)
